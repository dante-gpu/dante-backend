package handlers

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"github.com/dante-gpu/dante-backend/provider-registry-service/internal/config"
	"github.com/dante-gpu/dante-backend/provider-registry-service/internal/models"
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

// ProviderStore defines the interface for provider storage operations.
// This allows us to use the in-memory store or a DB store interchangeably.
type ProviderStore interface {
	AddProvider(ctx context.Context, provider *models.Provider) error
	GetProvider(ctx context.Context, id uuid.UUID) (*models.Provider, error)
	ListProviders(ctx context.Context) ([]*models.Provider, error)
	UpdateProvider(ctx context.Context, id uuid.UUID, updatedProvider *models.Provider) error
	DeleteProvider(ctx context.Context, id uuid.UUID) error
	UpdateProviderStatus(ctx context.Context, id uuid.UUID, status models.ProviderStatus) error
	UpdateProviderHeartbeat(ctx context.Context, id uuid.UUID) error
	Initialize(ctx context.Context) error
	Close() error
}

// ProviderHandler holds dependencies for provider API handlers.
// It uses the ProviderStore interface.
type ProviderHandler struct {
	Logger *zap.Logger
	Config *config.Config
	Store  ProviderStore
}

// NewProviderHandler creates a new ProviderHandler with the given dependencies.
func NewProviderHandler(logger *zap.Logger, cfg *config.Config, store ProviderStore) *ProviderHandler {
	return &ProviderHandler{
		Logger: logger,
		Config: cfg,
		Store:  store,
	}
}

// Routes defines all HTTP routes for the provider service.
func (h *ProviderHandler) Routes() chi.Router {
	r := chi.NewRouter()
	r.Post("/", h.RegisterProvider)       // POST /providers
	r.Get("/", h.ListProviders)           // GET /providers
	r.Get("/{providerID}", h.GetProvider) // GET /providers/{providerID}
	// PUT for full update, PATCH for partial (status, heartbeat)
	r.Put("/{providerID}", h.UpdateProvider)                // PUT /providers/{providerID}
	r.Patch("/{providerID}/status", h.UpdateProviderStatus) // PATCH /providers/{providerID}/status
	r.Post("/{providerID}/heartbeat", h.ProviderHeartbeat)  // POST /providers/{providerID}/heartbeat
	r.Delete("/{providerID}", h.DeregisterProvider)         // DELETE /providers/{providerID}
	return r
}

// --- Request/Response Structs (if different from models.Provider) ---

// RegisterProviderRequest is the expected structure for provider registration.
// It mirrors models.Provider but omits fields generated by the server (ID, Timestamps, initial Status).
type RegisterProviderRequest struct {
	OwnerID   string                 `json:"owner_id"`
	Name      string                 `json:"name"`
	Hostname  string                 `json:"hostname,omitempty"`
	IPAddress string                 `json:"ip_address,omitempty"`
	GPUs      []models.GPUDetail     `json:"gpus"`
	Location  string                 `json:"location,omitempty"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// UpdateProviderStatusRequest defines the payload for updating status.
type UpdateProviderStatusRequest struct {
	Status models.ProviderStatus `json:"status"`
}

// --- Handler Implementations ---

// RegisterProvider handles new provider registration.
func (h *ProviderHandler) RegisterProvider(w http.ResponseWriter, r *http.Request) {
	var req RegisterProviderRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.Logger.Error("Failed to decode provider registration request", zap.Error(err))
		RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	// Basic validation (more can be added)
	if req.Name == "" || req.OwnerID == "" || len(req.GPUs) == 0 {
		RespondWithError(w, http.StatusBadRequest, "Missing required fields: owner_id, name, gpus")
		return
	}

	provider := models.NewProvider(req.OwnerID, req.Name, req.Hostname, req.IPAddress, req.Location, req.GPUs, req.Metadata)

	if err := h.Store.AddProvider(r.Context(), provider); err != nil {
		if err == models.ErrProviderAlreadyExists {
			RespondWithError(w, http.StatusConflict, err.Error())
		} else {
			h.Logger.Error("Failed to add provider to store", zap.Error(err))
			RespondWithError(w, http.StatusInternalServerError, "Failed to register provider")
		}
		return
	}

	h.Logger.Info("Provider registered successfully", zap.String("provider_id", provider.ID.String()), zap.String("name", provider.Name))
	RespondWithJSON(w, http.StatusCreated, provider)
}

// ListProviders retrieves a list of registered providers.
func (h *ProviderHandler) ListProviders(w http.ResponseWriter, r *http.Request) {
	// TODO: Implement filtering based on query parameters üëÄüë®üèª‚Äçüç≥
	providers, err := h.Store.ListProviders(r.Context())
	if err != nil {
		h.Logger.Error("Failed to list providers from store", zap.Error(err))
		RespondWithError(w, http.StatusInternalServerError, "Failed to retrieve providers")
		return
	}
	RespondWithJSON(w, http.StatusOK, providers)
}

// GetProvider retrieves a specific provider by its ID.
func (h *ProviderHandler) GetProvider(w http.ResponseWriter, r *http.Request) {
	providerIDStr := chi.URLParam(r, "providerID")
	providerID, err := uuid.Parse(providerIDStr)
	if err != nil {
		RespondWithError(w, http.StatusBadRequest, "Invalid provider ID format")
		return
	}

	provider, err := h.Store.GetProvider(r.Context(), providerID)
	if err != nil {
		if err == models.ErrProviderNotFound {
			RespondWithError(w, http.StatusNotFound, err.Error())
		} else {
			h.Logger.Error("Failed to get provider from store", zap.String("provider_id", providerIDStr), zap.Error(err))
			RespondWithError(w, http.StatusInternalServerError, "Failed to retrieve provider")
		}
		return
	}
	RespondWithJSON(w, http.StatusOK, provider)
}

// UpdateProvider handles full updates to a provider's details.
func (h *ProviderHandler) UpdateProvider(w http.ResponseWriter, r *http.Request) {
	providerIDStr := chi.URLParam(r, "providerID")
	providerID, err := uuid.Parse(providerIDStr)
	if err != nil {
		RespondWithError(w, http.StatusBadRequest, "Invalid provider ID format")
		return
	}

	var req models.Provider // Expecting full provider object for PUT
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.Logger.Error("Failed to decode update provider request", zap.Error(err))
		RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	// Ensure the ID in the path matches the ID in the body, or just use the path ID.
	req.ID = providerID
	// Update timestamps are handled by the model or store logic when implemented with DB.
	// For in-memory, we might need to explicitly set LastSeenAt if not using the model methods.
	req.LastSeenAt = time.Now().UTC()

	if err := h.Store.UpdateProvider(r.Context(), providerID, &req); err != nil {
		if err == models.ErrProviderNotFound {
			RespondWithError(w, http.StatusNotFound, err.Error())
		} else {
			h.Logger.Error("Failed to update provider in store", zap.String("provider_id", providerIDStr), zap.Error(err))
			RespondWithError(w, http.StatusInternalServerError, "Failed to update provider")
		}
		return
	}
	RespondWithJSON(w, http.StatusOK, &req)
}

// UpdateProviderStatus handles partial updates to a provider's status.
func (h *ProviderHandler) UpdateProviderStatus(w http.ResponseWriter, r *http.Request) {
	providerIDStr := chi.URLParam(r, "providerID")
	providerID, err := uuid.Parse(providerIDStr)
	if err != nil {
		RespondWithError(w, http.StatusBadRequest, "Invalid provider ID format")
		return
	}

	var req UpdateProviderStatusRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.Logger.Error("Failed to decode update provider status request", zap.Error(err))
		RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	// Validate status value (optional, if ProviderStatus has more complex rules)

	if err := h.Store.UpdateProviderStatus(r.Context(), providerID, req.Status); err != nil {
		if err == models.ErrProviderNotFound {
			RespondWithError(w, http.StatusNotFound, err.Error())
		} else {
			h.Logger.Error("Failed to update provider status in store", zap.String("provider_id", providerIDStr), zap.Error(err))
			RespondWithError(w, http.StatusInternalServerError, "Failed to update provider status")
		}
		return
	}
	RespondWithJSON(w, http.StatusOK, map[string]string{"message": "Provider status updated"})
}

// ProviderHeartbeat handles heartbeat signals from providers.
func (h *ProviderHandler) ProviderHeartbeat(w http.ResponseWriter, r *http.Request) {
	providerIDStr := chi.URLParam(r, "providerID")
	providerID, err := uuid.Parse(providerIDStr)
	if err != nil {
		RespondWithError(w, http.StatusBadRequest, "Invalid provider ID format")
		return
	}

	if err := h.Store.UpdateProviderHeartbeat(r.Context(), providerID); err != nil {
		if err == models.ErrProviderNotFound {
			RespondWithError(w, http.StatusNotFound, err.Error())
		} else {
			h.Logger.Error("Failed to process provider heartbeat", zap.String("provider_id", providerIDStr), zap.Error(err))
			RespondWithError(w, http.StatusInternalServerError, "Failed to process heartbeat")
		}
		return
	}
	RespondWithJSON(w, http.StatusOK, map[string]string{"message": "Heartbeat received"})
}

// DeregisterProvider handles provider deregistration.
func (h *ProviderHandler) DeregisterProvider(w http.ResponseWriter, r *http.Request) {
	providerIDStr := chi.URLParam(r, "providerID")
	providerID, err := uuid.Parse(providerIDStr)
	if err != nil {
		RespondWithError(w, http.StatusBadRequest, "Invalid provider ID format")
		return
	}

	if err := h.Store.DeleteProvider(r.Context(), providerID); err != nil {
		if err == models.ErrProviderNotFound {
			RespondWithError(w, http.StatusNotFound, err.Error())
		} else {
			h.Logger.Error("Failed to delete provider from store", zap.String("provider_id", providerIDStr), zap.Error(err))
			RespondWithError(w, http.StatusInternalServerError, "Failed to deregister provider")
		}
		return
	}

	h.Logger.Info("Provider deregistered successfully", zap.String("provider_id", providerIDStr))
	RespondWithJSON(w, http.StatusOK, map[string]string{"message": "Provider deregistered successfully"})
}

// RespondWithError is a helper to send JSON error responses.
func RespondWithError(w http.ResponseWriter, code int, message string) {
	RespondWithJSON(w, code, map[string]string{"error": message})
}

// RespondWithJSON is a helper to send JSON responses.
func RespondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
	response, err := json.Marshal(payload)
	if err != nil {
		// If marshalling fails, log and send a generic server error
		// This should ideally not happen if payload is well-formed
		// logger.Error("Failed to marshal JSON response", zap.Error(err)) // Need logger here or pass it
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte("{\"error\": \"Failed to marshal response\"}"))
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(response)
}
